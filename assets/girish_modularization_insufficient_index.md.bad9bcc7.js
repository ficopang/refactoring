import{_ as e,c as i,o as t,b as a,d as n,a as r}from"./app.a804e8e4.js";const y=JSON.parse('{"title":"Insufficient Modularization","description":"","frontmatter":{},"headers":[{"level":2,"title":"Teori: Cyclomatic Complexity","slug":"teori-cyclomatic-complexity","link":"#teori-cyclomatic-complexity","children":[]},{"level":2,"title":"Penyebab","slug":"penyebab","link":"#penyebab","children":[]},{"level":2,"title":"Penyelesaian","slug":"penyelesaian","link":"#penyelesaian","children":[]},{"level":2,"title":"Julukan","slug":"julukan","link":"#julukan","children":[]},{"level":2,"title":"When to Ignore","slug":"when-to-ignore","link":"#when-to-ignore","children":[]},{"level":2,"title":"Referensi","slug":"referensi","link":"#referensi","children":[]}],"relativePath":"girish/modularization/insufficient/index.md"}'),l={name:"girish/modularization/insufficient/index.md"},s=a("h1",{id:"insufficient-modularization",tabindex:"-1"},[n("Insufficient Modularization "),a("a",{class:"header-anchor",href:"#insufficient-modularization","aria-hidden":"true"},"#")],-1),o=a("div",{class:"video-wrapper"},[a("iframe",{width:"560",height:"315",src:"https://www.youtube.com/embed/eRAoks2udlk",title:"YouTube video player",frameborder:"0",allow:"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture",allowfullscreen:""})],-1),d=r('<p>Smell ini terjadi karena adanya abstraksi yang terlalu besar dan harus dipecahkan (dekomposisi) ke beberapa abstraksi baru. Terdapat 2 jenis smell yaitu:</p><ul><li><strong>Bloated interface</strong>: Abstraksi yang mempunyai banyak member dalam public interface. Smell ini disamaratakan dengan <a href="./../../../martin-fowler/bloaters/large-class/">Large Class</a>.</li><li><strong>Bloated implementation</strong>: Abstraksi dengan jumlah method yang banyak ataupun memiliki kompleksitas yang terlalu kompleks. Smell ini disamaratakan dengan <a href="./../../../martin-fowler/bloaters/long-method/">Long Method</a>.</li></ul><h2 id="teori-cyclomatic-complexity" tabindex="-1">Teori: Cyclomatic Complexity <a class="header-anchor" href="#teori-cyclomatic-complexity" aria-hidden="true">#</a></h2><p>Pada kedua jenis smell ini, kompleksitas pada suatu method dapat diprediksi dengan <a href="https://en.wikipedia.org/wiki/Cyclomatic_complexity" target="_blank" rel="noreferrer">rumus cyclomatic complexity McCabe</a> (bukan McTerong) yaitu <em><code>M = E \u2212 N + 2P</code></em> dimana:</p><ul><li><em>M</em> merepresentasikan magic number untuk kompleksitas cyclomatic per-satuan method/routines,</li><li><em>E</em> merepresentasikan jumlah edges (alur method),</li><li><em>N</em> merepresentasikan jumlah nodes (statements), dan</li><li><em>P</em> merepresentasikan jumlah connected components (jumlah method) yang dijalankan. (Tambahkan P jika dilakukan secara rekursif atau tambahkan 2 jika hanya 1 method)</li></ul><p>Jika magic number cyclomatic complexity dari implementation (satuan method) tersebut <strong>lebih dari 10</strong>, maka smell Insuffient Modularization tipe bloated implementation bisa terjadi pada abstraksi tersebut.</p><p>Untuk mengetahui lebih jauh mengenai kompleksitas suatu method/abstraksi secara cyclomatic, dapat dilihat referensi lebih jauh melalui buku &quot;Software Testing: A Craftsman&#39;s Approach, Third Edition&quot; karangan Paul C. Jorgensen (Bab 9, Hal 139-146) atau melalui rangkuman <a href="https://socs.binus.ac.id/2016/12/29/software-testing-perhitungan-cyclomatic-complexity/" target="_blank" rel="noreferrer">Software Testing: Perhitungan Cyclomatic Complexity</a> yang dipublikasikan di <a href="http://socs.binus.ac.id" target="_blank" rel="noreferrer">socs.binus.ac.id</a>.</p><h2 id="penyebab" tabindex="-1">Penyebab <a class="header-anchor" href="#penyebab" aria-hidden="true">#</a></h2><ul><li><strong>Providing centralized control</strong>: Dimana pada kasus smell ini disebabkan karena adanya pemusatan kerjaan dan kendali dalam satu abstraksi atau dalam suatu method dalam abstraksi.</li><li><strong>Creating large classes for use by multiple clients</strong>: Developer membuat class besar agar dapat dipakai oleh multiple client.</li><li><strong>Grouping all related functionality together</strong>: Developer awam terkadang mengelompokkan beberapa fungsionalitas ke dalam 1 class tanpa memahami fungsinya Single Responsibility Principle (SRP) yang terkadang menimbulkan pembludakan interface/class.</li></ul><h2 id="penyelesaian" tabindex="-1">Penyelesaian <a class="header-anchor" href="#penyelesaian" aria-hidden="true">#</a></h2><p>Jika kasus ini berkaitan dengan bloated interface, maka perlu dicek member (method dan field) beserta tanggungjawabnya. Jika member tersebut ternyata berperan diluar tanggungjawab utama class tersebut, extract ke class baru.</p><p>Jika kasus ini berkaitan dengan bloated implementation, perlu dicek kompleksitas method sebelum method tersebut dipecahkan/diekstrak ke private helper method. Jika kasus smell ini terjadi berbarengan dengan smell <a href="./../../abstraction/multifaceted/">Multifaceted Abstraction</a>, maka pecahkan/ekstrak dan enkapsulasikan setiap pertanggungjawaban dalam masing-masing abstraksi baru atau yang telah ada.</p><h2 id="julukan" tabindex="-1">Julukan <a class="header-anchor" href="#julukan" aria-hidden="true">#</a></h2><ul><li><a href="https://en.wikipedia.org/wiki/God_object" target="_blank" rel="noreferrer"><strong>God class</strong></a>: Terjadi karena satu class terdiri dari &gt; 50 method atau attributes.</li><li><a href="https://en.wikipedia.org/wiki/Interface_bloat" target="_blank" rel="noreferrer"><strong>Fat interface</strong></a>: Interface yang disediakan oleh class tidak kohesif.</li><li><a href="https://sourcemaking.com/antipatterns/the-blob" target="_blank" rel="noreferrer"><strong>Blob class</strong></a>: Class terlalu besar dan terlalu kompleks.</li><li><strong>Classes with complex control flow</strong>: Class terlalu kompleks secara cyclomatic complexity (nilai magic number of cyclomatic complexity sangat tinggi).</li><li><strong>Too much responsibility</strong>: Class memegang tanggungjawab terlalu banyak.</li></ul><h2 id="when-to-ignore" tabindex="-1">When to Ignore <a class="header-anchor" href="#when-to-ignore" aria-hidden="true">#</a></h2><ul><li><strong>Key classes</strong>: Merupakan class yang krusial dan penting, juga berukuran besar, kompleks, dan terhubung dengan banyak class.</li><li><strong>Auto-generated code</strong>: Jika code tersebut digenerate secara otomatis dari generator mempunyai method yang kompleks sehingga sulit untuk direfactor/modifikasi.</li></ul><h2 id="referensi" tabindex="-1">Referensi <a class="header-anchor" href="#referensi" aria-hidden="true">#</a></h2><ul><li>Paul C. Jorgensen, &quot;Software Testing: A Craftsman&#39;s Approach, Third Edition&quot;, Bab 9, Hal 139-146. CRC Press. 2013.</li><li>Gautham Prabhuk, &quot;SOFTWARE METRICS,&quot; 22 Dec 2014. Wordpress. Available at <a href="https://gauthamprabhuk.wordpress.com/2014/12/22/software-metrics" target="_blank" rel="noreferrer">https://gauthamprabhuk.wordpress.com/2014/12/22/software-metrics</a></li></ul>',18),u=[s,o,d];function m(c,h,k,p,g,b){return t(),i("div",null,u)}const _=e(l,[["render",m]]);export{y as __pageData,_ as default};
