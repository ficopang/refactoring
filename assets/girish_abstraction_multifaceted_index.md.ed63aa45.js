import{_ as i,c as l,b as e,d as a,e as s,w as r,a as t,r as o,o as d}from"./app.a804e8e4.js";const j=JSON.parse('{"title":"Multifaceted Abstraction","description":"","frontmatter":{},"headers":[{"level":2,"title":"Penyebab Smell","slug":"penyebab-smell","link":"#penyebab-smell","children":[]},{"level":2,"title":"Contoh","slug":"contoh","link":"#contoh","children":[]},{"level":2,"title":"Masalah","slug":"masalah","link":"#masalah","children":[{"level":3,"title":"Penyelesaian","slug":"penyelesaian","link":"#penyelesaian","children":[]}]}],"relativePath":"girish/abstraction/multifaceted/index.md"}'),c={name:"girish/abstraction/multifaceted/index.md"},h=t('<h1 id="multifaceted-abstraction" tabindex="-1">Multifaceted Abstraction <a class="header-anchor" href="#multifaceted-abstraction" aria-hidden="true">#</a></h1><p>Smell ini terjadi ketika ada class yang memiliki lebih dari satu tanggungjawab (violasi SRP).</p><p>Smell ini mirip dengan smell divergent change Martin Fowler. Biasanya divergent change disertai juga dengan smell large class.</p><h2 id="penyebab-smell" tabindex="-1">Penyebab Smell <a class="header-anchor" href="#penyebab-smell" aria-hidden="true">#</a></h2><ul><li><strong>General-purpose abstractions</strong>: software developer melakukan desain abstraksi yang berujung <a href="https://en.wikipedia.org/wiki/God_object" target="_blank" rel="noreferrer">God Object</a>.</li><li><strong>Evolution without periodic refactoring</strong>: awalnya class masih langsing, namun seiring bertambahnya fitur, class bertambah tanggungjawab baru. Seharusnya ketika class semakin gemuk, developer sudah saatnya melakukan refactoring.</li><li><strong>The burden of processes</strong>: developer malas. Menambah method di class yang sudah ada memang lebih mudah ketimbang membuat class baru.</li></ul><h2 id="contoh" tabindex="-1">Contoh <a class="header-anchor" href="#contoh" aria-hidden="true">#</a></h2><h2 id="masalah" tabindex="-1">Masalah <a class="header-anchor" href="#masalah" aria-hidden="true">#</a></h2>',7),u=e("code",null,"before",-1),g=e("code",null,"width",-1),m=e("code",null,"weight",-1),_=e("code",null,"area()",-1),b=e("code",null,"perimeter()",-1),p=e("code",null,"print(String style)",-1),k=t('<p>Pada umumnya, domain logic dan presentation logic dipisah. Kita bisa berargumen bahwa class Rectangle memiliki dua tanggungjawab, yaitu mengurus kalkulasi Rectangle dan juga mengatur tampilan Rectangle ke dalam console.</p><h3 id="penyelesaian" tabindex="-1">Penyelesaian <a class="header-anchor" href="#penyelesaian" aria-hidden="true">#</a></h3><p>Kita pindahkan method <code>print</code> di class <code>Rectangle</code> ke class yang baru. Karena di <code>print</code> juga terdapat smell primitive obsession, sekalian kita buatkan struktur baru menggunakan strategy design pattern. Perhatikan hasil refactor-nya di package <code>after</code>.</p>',3);function f(y,v,S,T,w,x){const n=o("github-url");return d(),l("div",null,[h,e("p",null,[a("Perhatikan class "),s(n,{to:"before/Rectangle.java"},{default:r(()=>[a("Rectangle")]),_:1}),a(" di package "),u,a(". Disana terdapat field "),g,a(" dan "),m,a(". Terdapat method "),_,a(" dan "),b,a(". Dan juga terdapat method "),p,a(".")]),k])}const R=i(c,[["render",f]]);export{j as __pageData,R as default};
